/* eslint-disable no-unused-vars */
// This file is auto-generated by generate_classes so do not edit manually

const Element = require('../complex_types/element');


/**
DataRequirement
    Describes a required data item for evaluation in terms of the type of data,
    and optional code or date-based filters of the data.
    If the element is present, it must have a value for at least one of the
    defined elements, an @id referenced from the Narrative, or extensions
*/
class DataRequirement extends Element {
    /**
     * @param {String|undefined} [id],
     * @param {Extension[]|undefined} [extension],
     * @param {code} type,
     * @param {canonical[]|undefined} [profile],
     * @param {CodeableConcept|undefined} [subjectCodeableConcept],
     * @param {Reference|undefined} [subjectReference],
     * @param {String[]|undefined} [mustSupport],
     * @param {DataRequirementCodeFilter[]|undefined} [codeFilter],
     * @param {DataRequirementDateFilter[]|undefined} [dateFilter],
     * @param {Int|undefined} [limit],
     * @param {DataRequirementSort[]|undefined} [sort],
    */
    constructor(
        {
            id,
            extension,
            type,
            profile,
            subjectCodeableConcept,
            subjectReference,
            mustSupport,
            codeFilter,
            dateFilter,
            limit,
            sort,
        }
    ) {
        super({});

        // ---- Define getters and setters as enumerable ---

        /**
         * @description None
         * @property {String|undefined}
        */
        Object.defineProperty(this, 'id', {
            enumerable: true,
            get: () => this.__data.id,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                this.__data.id = valueProvided;
            }
        });

        /**
         * @description May be used to represent additional information that is not part of the basic
    definition of the element. To make the use of extensions safe and manageable,
    there is a strict set of governance  applied to the definition and use of
    extensions. Though any implementer can define an extension, there is a set of
    requirements that SHALL be met as part of the definition of the extension.
         * @property {Extension[]|undefined}
        */
        Object.defineProperty(this, 'extension', {
            enumerable: true,
            get: () => this.__data.extension,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                let Extension = require('../extensions/extension.js');
                this.__data.extension = Array.isArray(valueProvided) ? valueProvided.map(v => new Extension(v)) : [new Extension(valueProvided)];
            }
        });

        /**
         * @description The type of the required data, specified as the type name of a resource. For
    profiles, this value is set to the type of the base resource of the profile.
         * @property {code}
        */
        Object.defineProperty(this, 'type', {
            enumerable: true,
            get: () => this.__data.type,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                this.__data.type = valueProvided;
            }
        });

        /**
         * @description The profile of the required data, specified as the uri of the profile
    definition.
         * @property {canonical[]|undefined}
        */
        Object.defineProperty(this, 'profile', {
            enumerable: true,
            get: () => this.__data.profile,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                this.__data.profile = Array.isArray(valueProvided) ? valueProvided.map(v => v) : [valueProvided];
            }
        });

        /**
         * @description None
         * @property {CodeableConcept|undefined}
        */
        Object.defineProperty(this, 'subjectCodeableConcept', {
            enumerable: true,
            get: () => this.__data.subjectCodeableConcept,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                let CodeableConcept = require('../complex_types/codeableConcept.js');
                this.__data.subjectCodeableConcept = new CodeableConcept(valueProvided);
            }
        });

        /**
         * @description None
         * @property {Reference|undefined}
        */
        Object.defineProperty(this, 'subjectReference', {
            enumerable: true,
            get: () => this.__data.subjectReference,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                let Reference = require('../complex_types/reference.js');
                this.__data.subjectReference = new Reference(valueProvided);
            }
        });

        /**
         * @description Indicates that specific elements of the type are referenced by the knowledge
    module and must be supported by the consumer in order to obtain an effective
    evaluation. This does not mean that a value is required for this element, only
    that the consuming system must understand the element and be able to provide
    values for it if they are available.

    The value of mustSupport SHALL be a FHIRPath resolveable on the type of the
    DataRequirement. The path SHALL consist only of identifiers, constant
    indexers, and .resolve() (see the [Simple FHIRPath
    Profile](fhirpath.html#simple) for full details).
         * @property {String[]|undefined}
        */
        Object.defineProperty(this, 'mustSupport', {
            enumerable: true,
            get: () => this.__data.mustSupport,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                this.__data.mustSupport = Array.isArray(valueProvided) ? valueProvided.map(v => v) : [valueProvided];
            }
        });

        /**
         * @description Code filters specify additional constraints on the data, specifying the value
    set of interest for a particular element of the data. Each code filter defines
    an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
         * @property {DataRequirementCodeFilter[]|undefined}
        */
        Object.defineProperty(this, 'codeFilter', {
            enumerable: true,
            get: () => this.__data.codeFilter,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                let DataRequirementCodeFilter = require('../complex_types/dataRequirementCodeFilter.js');
                this.__data.codeFilter = Array.isArray(valueProvided) ? valueProvided.map(v => new DataRequirementCodeFilter(v)) : [new DataRequirementCodeFilter(valueProvided)];
            }
        });

        /**
         * @description Date filters specify additional constraints on the data in terms of the
    applicable date range for specific elements. Each date filter specifies an
    additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
         * @property {DataRequirementDateFilter[]|undefined}
        */
        Object.defineProperty(this, 'dateFilter', {
            enumerable: true,
            get: () => this.__data.dateFilter,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                let DataRequirementDateFilter = require('../complex_types/dataRequirementDateFilter.js');
                this.__data.dateFilter = Array.isArray(valueProvided) ? valueProvided.map(v => new DataRequirementDateFilter(v)) : [new DataRequirementDateFilter(valueProvided)];
            }
        });

        /**
         * @description Specifies a maximum number of results that are required (uses the _count
    search parameter).
         * @property {Int|undefined}
        */
        Object.defineProperty(this, 'limit', {
            enumerable: true,
            get: () => this.__data.limit,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                this.__data.limit = valueProvided;
            }
        });

        /**
         * @description Specifies the order of the results to be returned.
         * @property {DataRequirementSort[]|undefined}
        */
        Object.defineProperty(this, 'sort', {
            enumerable: true,
            get: () => this.__data.sort,
            set: valueProvided => {
                if (valueProvided === undefined || valueProvided === null) {
                    return;
                }
                let DataRequirementSort = require('../complex_types/dataRequirementSort.js');
                this.__data.sort = Array.isArray(valueProvided) ? valueProvided.map(v => new DataRequirementSort(v)) : [new DataRequirementSort(valueProvided)];
            }
        });

        Object.assign(this, {
            id,
            extension,
            type,
            profile,
            subjectCodeableConcept,
            subjectReference,
            mustSupport,
            codeFilter,
            dateFilter,
            limit,
            sort,
        });

        // Define a default non-writable resourceType property

        Object.defineProperty(this, 'resourceType', {
            value: 'DataRequirement',
            enumerable: true,
            writable: false
        });
    }

    static get resourceType() {
        return 'DataRequirement';
    }

    toJSON() {
        return {
            id: this.id,
            extension: this.extension && this.extension.map(v => v.toJSON()),
            type: this.type,
            profile: this.profile,
            subjectCodeableConcept: this.subjectCodeableConcept && this.subjectCodeableConcept.toJSON(),
            subjectReference: this.subjectReference && this.subjectReference.toJSON(),
            mustSupport: this.mustSupport,
            codeFilter: this.codeFilter && this.codeFilter.map(v => v.toJSON()),
            dateFilter: this.dateFilter && this.dateFilter.map(v => v.toJSON()),
            limit: this.limit,
            sort: this.sort && this.sort.map(v => v.toJSON()),
        };
    }
}

module.exports = DataRequirement;
